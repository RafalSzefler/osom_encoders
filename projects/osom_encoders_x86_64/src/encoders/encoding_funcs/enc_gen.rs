//! # Auto-generated
//!
//! This file was generated by a build script.
//!
//! The build script monitors this file and regenerates it on changes.
//! Manual modifications will be lost.
//!
//! # Content
//!
//! Holds encoders for instructions valid in 64-bit X86 instruction set.
#![allow(non_snake_case)]
#![allow(unused_imports)]
#![allow(clippy::needless_pass_by_value)]
#![allow(clippy::wildcard_imports)]

use crate::encoders::utils;
use crate::models::{
    EncodedX86_64Instruction, GPR, GPROrMemory, Immediate8, Immediate16, Immediate32, Immediate64, Memory,
};

/// Holds encoders for instructions that have only one variant.
pub mod singleton {
    use super::*;

    /// No operation.
    #[inline(always)]
    pub const fn encode_nop() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0x90]) }
    }

    /// Lock prefix used for atomic operations.
    #[inline(always)]
    pub const fn encode_lock() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0xF0]) }
    }

    /// Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
    #[inline(always)]
    pub const fn encode_cpuid() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0x0F, 0xA2]) }
    }

    /// Fast call to privilege level 0 system procedures.
    #[inline(always)]
    pub const fn encode_sysenter() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0x0F, 0x34]) }
    }

    /// Fast call to privilege level 0 system procedures. New variant of sysenter for 64-bit mode.
    #[inline(always)]
    pub const fn encode_syscall() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0x0F, 0x05]) }
    }
}

/// Holds encoders for variants of `ret` instruction.
pub mod ret {
    use super::*;

    /// Return to calling procedure.
    #[inline(always)]
    pub const fn encode_ret() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0xC3]) }
    }

    /// Pop [16-bit immediate] bytes from stack and return to calling procedure.
    #[inline(always)]
    pub const fn encode_ret_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16([0xC2], imm16) }
    }
}

/// Holds encoders for variants of `mov` instruction.
pub mod mov {
    use super::*;

    /// Move 8-bit immediate to 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm8_imm8(rm8: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm8_imm8([0xC6], 0x00, &rm8, imm8) }
    }

    /// Move 16-bit immediate to 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm16_imm16(rm16: GPROrMemory, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm16([0xC7], 0x00, &rm16, imm16) }
    }

    /// Move 32-bit immediate to 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm32_imm32(rm32: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm32([0xC7], 0x00, &rm32, imm32) }
    }

    /// Move 32-bit immediate to 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm64_imm32(rm64: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm32([0xC7], 0x00, &rm64, imm32) }
    }

    /// Move 8-bit immediate to 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg8_imm8(reg8: GPR, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_OI::encode_OI_r8_imm8(0xB0, reg8, imm8) }
    }

    /// Move 16-bit immediate to 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg16_imm16(reg16: GPR, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_OI::encode_OI_r16_imm16(0xB8, reg16, imm16) }
    }

    /// Move 32-bit immediate to 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg32_imm32(reg32: GPR, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_OI::encode_OI_r32_imm32(0xB8, reg32, imm32) }
    }

    /// Move 64-bit immediate to 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg64_imm64(reg64: GPR, imm64: Immediate64) -> EncodedX86_64Instruction {
        unsafe { utils::enc_OI::encode_OI_r64_imm64(0xB8, reg64, imm64) }
    }

    /// Move 8-bit register to 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm8_reg8(rm8: GPROrMemory, reg8: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x88], &rm8, reg8) }
    }

    /// Move 16-bit register to 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm16_reg16(rm16: GPROrMemory, reg16: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x89], &rm16, reg16) }
    }

    /// Move 32-bit register to 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm32_reg32(rm32: GPROrMemory, reg32: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x89], &rm32, reg32) }
    }

    /// Move 64-bit register to 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_rm64_reg64(rm64: GPROrMemory, reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x89], &rm64, reg64) }
    }

    /// Move 8-bit register or memory to 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg8_rm8(reg8: GPR, rm8: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x8A], &rm8, reg8) }
    }

    /// Move 16-bit register or memory to 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg16_rm16(reg16: GPR, rm16: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x8B], &rm16, reg16) }
    }

    /// Move 32-bit register or memory to 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg32_rm32(reg32: GPR, rm32: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x8B], &rm32, reg32) }
    }

    /// Move 64-bit register or memory to 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_mov_reg64_rm64(reg64: GPR, rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x8B], &rm64, reg64) }
    }
}

/// Holds encoders for variants of `push` instruction.
pub mod push {
    use super::*;

    /// Push 64-bit register or memory onto the stack.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_push_rm64(rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_M::encode_M_gpr_or_memory([0xFF], 0x06, &rm64, false, false) }
    }

    /// Push 64-bit register onto the stack.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_push_reg64(reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_O::encode_O(0x50, reg64) }
    }

    /// Push 8-bit immediate onto the stack (sign-extended).
    #[inline(always)]
    pub const fn encode_push_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x6A], imm8) }
    }

    /// Push 16-bit immediate onto the stack (sign-extended).
    #[inline(always)]
    pub const fn encode_push_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16_operand_size_override([0x68], imm16) }
    }

    /// Push 32-bit immediate onto the stack (sign-extended).
    #[inline(always)]
    pub const fn encode_push_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x68], imm32) }
    }
}

/// Holds encoders for variants of `pop` instruction.
pub mod pop {
    use super::*;

    /// Pop 64-bit value from the stack into register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_pop_rm64(rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_M::encode_M_gpr_or_memory([0x8F], 0x00, &rm64, false, false) }
    }

    /// Pop 64-bit value from the stack into register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_pop_reg64(reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_O::encode_O(0x58, reg64) }
    }
}

/// Holds encoders for variants of `lea` instruction.
pub mod lea {
    use super::*;

    /// Load effective address from memory into 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_lea_reg16_m(reg16: GPR, m: Memory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR_m([0x8D], &m, reg16) }
    }

    /// Load effective address from memory into 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_lea_reg32_m(reg32: GPR, m: Memory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR_m([0x8D], &m, reg32) }
    }

    /// Load effective address from memory into 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_lea_reg64_m(reg64: GPR, m: Memory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR_m([0x8D], &m, reg64) }
    }
}

/// Holds encoders for variants of `add` instruction.
pub mod add {
    use super::*;

    /// Add 8-bit immediate to AL register.
    #[inline(always)]
    pub const fn encode_add_AL_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x04], imm8) }
    }

    /// Add 16-bit immediate to AX register.
    #[inline(always)]
    pub const fn encode_add_AX_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16_operand_size_override([0x05], imm16) }
    }

    /// Add 32-bit immediate to EAX register.
    #[inline(always)]
    pub const fn encode_add_EAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x05], imm32) }
    }

    /// Add 32-bit immediate to RAX register (sign-extended to 64 bits).
    #[inline(always)]
    pub const fn encode_add_RAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32_prefix_rex_w([0x05], imm32) }
    }

    /// Add 8-bit immediate to 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm8_imm8(rm8: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm8_imm8([0x80], 0x00, &rm8, imm8) }
    }

    /// Add 16-bit immediate to 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm16_imm16(rm16: GPROrMemory, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm16([0x81], 0x00, &rm16, imm16) }
    }

    /// Add 32-bit immediate to 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm32_imm32(rm32: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm32([0x81], 0x00, &rm32, imm32) }
    }

    /// Add 32-bit immediate to 64-bit register or memory (sign-extended to 64 bits).
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm64_imm32(rm64: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm32([0x81], 0x00, &rm64, imm32) }
    }

    /// Add 8-bit immediate (sign-extended) to 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm16_imm8(rm16: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm8([0x83], 0x00, &rm16, imm8) }
    }

    /// Add 8-bit immediate (sign-extended) to 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm32_imm8(rm32: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm8([0x83], 0x00, &rm32, imm8) }
    }

    /// Add 8-bit immediate (sign-extended) to 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm64_imm8(rm64: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm8([0x83], 0x00, &rm64, imm8) }
    }

    /// Add 8-bit register to 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm8_reg8(rm8: GPROrMemory, reg8: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x00], &rm8, reg8) }
    }

    /// Add 16-bit register to 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm16_reg16(rm16: GPROrMemory, reg16: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x01], &rm16, reg16) }
    }

    /// Add 32-bit register to 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm32_reg32(rm32: GPROrMemory, reg32: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x01], &rm32, reg32) }
    }

    /// Add 64-bit register to 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_rm64_reg64(rm64: GPROrMemory, reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x01], &rm64, reg64) }
    }

    /// Add 8-bit register or memory to 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_reg8_rm8(reg8: GPR, rm8: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x02], &rm8, reg8) }
    }

    /// Add 16-bit register or memory to 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_reg16_rm16(reg16: GPR, rm16: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x03], &rm16, reg16) }
    }

    /// Add 32-bit register or memory to 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_reg32_rm32(reg32: GPR, rm32: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x03], &rm32, reg32) }
    }

    /// Add 64-bit register or memory to 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_add_reg64_rm64(reg64: GPR, rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x03], &rm64, reg64) }
    }
}

/// Holds encoders for variants of `sub` instruction.
pub mod sub {
    use super::*;

    /// Subtract 8-bit immediate from AL register.
    #[inline(always)]
    pub const fn encode_sub_AL_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x2C], imm8) }
    }

    /// Subtract 16-bit immediate from AX register.
    #[inline(always)]
    pub const fn encode_sub_AX_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16_operand_size_override([0x2D], imm16) }
    }

    /// Subtract 32-bit immediate from EAX register.
    #[inline(always)]
    pub const fn encode_sub_EAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x2D], imm32) }
    }

    /// Subtract 32-bit immediate from RAX register (sign-extended to 64 bits).
    #[inline(always)]
    pub const fn encode_sub_RAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32_prefix_rex_w([0x2D], imm32) }
    }

    /// Subtract 8-bit immediate from 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm8_imm8(rm8: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm8_imm8([0x80], 0x05, &rm8, imm8) }
    }

    /// Subtract 16-bit immediate from 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm16_imm16(rm16: GPROrMemory, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm16([0x81], 0x05, &rm16, imm16) }
    }

    /// Subtract 32-bit immediate from 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm32_imm32(rm32: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm32([0x81], 0x05, &rm32, imm32) }
    }

    /// Subtract 32-bit immediate from 64-bit register or memory (sign-extended to 64 bits).
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm64_imm32(rm64: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm32([0x81], 0x05, &rm64, imm32) }
    }

    /// Subtract 8-bit immediate (sign-extended) from 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm16_imm8(rm16: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm8([0x83], 0x05, &rm16, imm8) }
    }

    /// Subtract 8-bit immediate (sign-extended) from 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm32_imm8(rm32: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm8([0x83], 0x05, &rm32, imm8) }
    }

    /// Subtract 8-bit immediate (sign-extended) from 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm64_imm8(rm64: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm8([0x83], 0x05, &rm64, imm8) }
    }

    /// Subtract 8-bit register from 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm8_reg8(rm8: GPROrMemory, reg8: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x28], &rm8, reg8) }
    }

    /// Subtract 16-bit register from 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm16_reg16(rm16: GPROrMemory, reg16: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x29], &rm16, reg16) }
    }

    /// Subtract 32-bit register from 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm32_reg32(rm32: GPROrMemory, reg32: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x29], &rm32, reg32) }
    }

    /// Subtract 64-bit register from 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_rm64_reg64(rm64: GPROrMemory, reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x29], &rm64, reg64) }
    }

    /// Subtract 8-bit register or memory from 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_reg8_rm8(reg8: GPR, rm8: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x2A], &rm8, reg8) }
    }

    /// Subtract 16-bit register or memory from 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_reg16_rm16(reg16: GPR, rm16: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x2B], &rm16, reg16) }
    }

    /// Subtract 32-bit register or memory from 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_reg32_rm32(reg32: GPR, rm32: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x2B], &rm32, reg32) }
    }

    /// Subtract 64-bit register or memory from 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_sub_reg64_rm64(reg64: GPR, rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x2B], &rm64, reg64) }
    }
}

/// Holds encoders for variants of `xor` instruction.
pub mod xor {
    use super::*;

    /// Bitwise XOR 8-bit immediate with AL register.
    #[inline(always)]
    pub const fn encode_xor_AL_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x34], imm8) }
    }

    /// Bitwise XOR 16-bit immediate with AX register.
    #[inline(always)]
    pub const fn encode_xor_AX_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16_operand_size_override([0x35], imm16) }
    }

    /// Bitwise XOR 32-bit immediate with EAX register.
    #[inline(always)]
    pub const fn encode_xor_EAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x35], imm32) }
    }

    /// Bitwise XOR 32-bit immediate with RAX register (sign-extended to 64 bits).
    #[inline(always)]
    pub const fn encode_xor_RAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32_prefix_rex_w([0x35], imm32) }
    }

    /// Bitwise XOR 8-bit immediate with 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm8_imm8(rm8: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm8_imm8([0x80], 0x06, &rm8, imm8) }
    }

    /// Bitwise XOR 16-bit immediate with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm16_imm16(rm16: GPROrMemory, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm16([0x81], 0x06, &rm16, imm16) }
    }

    /// Bitwise XOR 32-bit immediate with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm32_imm32(rm32: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm32([0x81], 0x06, &rm32, imm32) }
    }

    /// Bitwise XOR 32-bit immediate with 64-bit register or memory (sign-extended to 64 bits).
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm64_imm32(rm64: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm32([0x81], 0x06, &rm64, imm32) }
    }

    /// Bitwise XOR 8-bit immediate (sign-extended) with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm16_imm8(rm16: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm8([0x83], 0x06, &rm16, imm8) }
    }

    /// Bitwise XOR 8-bit immediate (sign-extended) with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm32_imm8(rm32: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm8([0x83], 0x06, &rm32, imm8) }
    }

    /// Bitwise XOR 8-bit immediate (sign-extended) with 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm64_imm8(rm64: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm8([0x83], 0x06, &rm64, imm8) }
    }

    /// Bitwise XOR 8-bit register with 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm8_reg8(rm8: GPROrMemory, reg8: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x30], &rm8, reg8) }
    }

    /// Bitwise XOR 16-bit register with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm16_reg16(rm16: GPROrMemory, reg16: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x31], &rm16, reg16) }
    }

    /// Bitwise XOR 32-bit register with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm32_reg32(rm32: GPROrMemory, reg32: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x31], &rm32, reg32) }
    }

    /// Bitwise XOR 64-bit register with 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_rm64_reg64(rm64: GPROrMemory, reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x31], &rm64, reg64) }
    }

    /// Bitwise XOR 8-bit register or memory with 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_reg8_rm8(reg8: GPR, rm8: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x32], &rm8, reg8) }
    }

    /// Bitwise XOR 16-bit register or memory with 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_reg16_rm16(reg16: GPR, rm16: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x33], &rm16, reg16) }
    }

    /// Bitwise XOR 32-bit register or memory with 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_reg32_rm32(reg32: GPR, rm32: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x33], &rm32, reg32) }
    }

    /// Bitwise XOR 64-bit register or memory with 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_xor_reg64_rm64(reg64: GPR, rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x33], &rm64, reg64) }
    }
}

/// Holds encoders for variants of `cmp` instruction.
pub mod cmp {
    use super::*;

    /// Compare 8-bit immediate with AL register.
    #[inline(always)]
    pub const fn encode_cmp_AL_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x3C], imm8) }
    }

    /// Compare 16-bit immediate with AX register.
    #[inline(always)]
    pub const fn encode_cmp_AX_imm16(imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm16_operand_size_override([0x3D], imm16) }
    }

    /// Compare 32-bit immediate with EAX register.
    #[inline(always)]
    pub const fn encode_cmp_EAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x3D], imm32) }
    }

    /// Compare 32-bit immediate sign-extended with RAX register.
    #[inline(always)]
    pub const fn encode_cmp_RAX_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32_prefix_rex_w([0x3D], imm32) }
    }

    /// Compare 8-bit immediate with 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm8_imm8(rm8: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm8_imm8([0x80], 0x07, &rm8, imm8) }
    }

    /// Compare 16-bit immediate with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm16_imm16(rm16: GPROrMemory, imm16: Immediate16) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm16([0x81], 0x07, &rm16, imm16) }
    }

    /// Compare 32-bit immediate with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm32_imm32(rm32: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm32([0x81], 0x07, &rm32, imm32) }
    }

    /// Compare 32-bit immediate with 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm64_imm32(rm64: GPROrMemory, imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm32([0x81], 0x07, &rm64, imm32) }
    }

    /// Compare 8-bit immediate (sign-extended) with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm16_imm8(rm16: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm16_imm8([0x83], 0x07, &rm16, imm8) }
    }

    /// Compare 8-bit immediate (sign-extended) with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm32_imm8(rm32: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm32_imm8([0x83], 0x07, &rm32, imm8) }
    }

    /// Compare 8-bit immediate (sign-extended) with 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm64_imm8(rm64: GPROrMemory, imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MI::encode_MI_rm64_imm8([0x83], 0x07, &rm64, imm8) }
    }

    /// Compare 8-bit register with 8-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm8_reg8(rm8: GPROrMemory, reg8: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x38], &rm8, reg8) }
    }

    /// Compare 16-bit register with 16-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm16_reg16(rm16: GPROrMemory, reg16: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x39], &rm16, reg16) }
    }

    /// Compare 32-bit register with 32-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm32_reg32(rm32: GPROrMemory, reg32: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x39], &rm32, reg32) }
    }

    /// Compare 64-bit register with 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_rm64_reg64(rm64: GPROrMemory, reg64: GPR) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x39], &rm64, reg64) }
    }

    /// Compare 8-bit register or memory with 8-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_reg8_rm8(reg8: GPR, rm8: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x3A], &rm8, reg8) }
    }

    /// Compare 16-bit register or memory with 16-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_reg16_rm16(reg16: GPR, rm16: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x3B], &rm16, reg16) }
    }

    /// Compare 32-bit register or memory with 32-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_reg32_rm32(reg32: GPR, rm32: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x3B], &rm32, reg32) }
    }

    /// Compare 64-bit register or memory with 64-bit register.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_cmp_reg64_rm64(reg64: GPR, rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_MR::encode_MR([0x3B], &rm64, reg64) }
    }
}

/// Holds encoders for variants of `jmp` instruction.
pub mod jmp {
    use super::*;

    /// Short jump to RIP-relative address. Takes 2 bytes only.
    #[inline(always)]
    pub const fn encode_jmp_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0xEB], imm8) }
    }

    /// Long jump to RIP-relative address. Takes 5 bytes.
    #[inline(always)]
    pub const fn encode_jmp_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0xE9], imm32) }
    }

    /// Jump to 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_jmp_rm64(rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_M::encode_M_gpr_or_memory([0xFF], 0x04, &rm64, false, false) }
    }
}

/// Holds encoders for variants of `jcc` instruction.
pub mod jcc {
    use super::*;

    /// Conditional short jump to RIP-relative address. Condition: Above (in unsigned sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_A_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x77], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Above (in unsigned sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_A_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x87], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Above Or Equal (in unsigned sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_AE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x73], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Above Or Equal (in unsigned sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_AE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x83], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Below (in unsigned sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_B_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x72], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Below (in unsigned sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_B_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x82], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Below Or Equal (in unsigned sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_BE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x76], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Below Or Equal (in unsigned sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_BE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x86], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Equal. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_E_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x74], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Equal. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_E_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x84], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Greater (in signed sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_G_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7F], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Greater (in signed sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_G_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8F], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Greater Or Equal (in signed sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_GE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7D], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Greater Or Equal (in signed sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_GE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8D], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Less (in signed sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_L_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7C], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Less (in signed sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_L_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8C], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Less Or Equal (in signed sense). Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_LE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7E], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Less Or Equal (in signed sense). Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_LE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8E], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Not Equal. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x75], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Not Equal. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x85], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: No Overflow. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NO_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x71], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: No Overflow. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NO_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x81], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: No Parity. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NP_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7B], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: No Parity. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NP_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8B], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: No Sign. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NS_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x79], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: No Sign. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NS_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x89], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Overflow. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_O_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x70], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Overflow. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_O_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x80], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Parity. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_P_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7A], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Parity. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_P_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8A], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Parity Even. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_PE_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7A], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Parity Even. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_PE_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8A], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Parity Odd. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_PO_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x7B], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Parity Odd. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_PO_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x8B], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Sign. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_S_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x78], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Sign. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_S_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x88], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Carry. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_C_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x72], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Carry. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_C_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x82], imm32) }
    }

    /// Conditional short jump to RIP-relative address. Condition: Not Carry. Takes 2 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NC_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0x73], imm8) }
    }

    /// Conditional long jump to RIP-relative address. Condition: Not Carry. Takes 6 bytes.
    #[inline(always)]
    pub const fn encode_jcc_NC_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0x0F, 0x83], imm32) }
    }
}

/// Holds encoders for variants of `call` instruction.
pub mod call {
    use super::*;

    /// Call to RIP-relative address.
    #[inline(always)]
    pub const fn encode_call_imm32(imm32: Immediate32) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm32([0xE8], imm32) }
    }

    /// Call to address in 64-bit register or memory.
    ///
    /// # Safety
    ///
    /// The caller has to ensure that the operands are valid,
    /// in particular the function does not check register sizes.
    #[inline(always)]
    pub const unsafe fn encode_call_rm64(rm64: GPROrMemory) -> EncodedX86_64Instruction {
        unsafe { utils::enc_M::encode_M_gpr_or_memory([0xFF], 0x02, &rm64, false, false) }
    }
}

/// Holds encoders for variants of `int` instruction.
pub mod int {
    use super::*;

    /// Generate software interrupt with vector specified by immediate byte.
    #[inline(always)]
    pub const fn encode_int_imm8(imm8: Immediate8) -> EncodedX86_64Instruction {
        unsafe { utils::enc_I::encode_I_imm8([0xCD], imm8) }
    }

    /// Generate debug trap. More or less equivalent to `int 1`.
    #[inline(always)]
    pub const fn encode_int_1() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0xF1]) }
    }

    /// Generate breakpoint trap. More or less equivalent to `int 3`.
    #[inline(always)]
    pub const fn encode_int_3() -> EncodedX86_64Instruction {
        unsafe { EncodedX86_64Instruction::from_array([0xCC]) }
    }
}
